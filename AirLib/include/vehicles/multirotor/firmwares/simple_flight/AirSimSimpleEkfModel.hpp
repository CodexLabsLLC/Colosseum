// Liscence info

#ifndef msr_airlib_AirSimSimpleEkfModel_hpp
#define msr_airlib_AirSimSimpleEkfModel_hpp

#include <exception>
#include <vector>
#include "firmware/interfaces/IUpdatable.hpp"
#include "firmware/interfaces/IBoard.hpp"
#include "common/FrequencyLimiter.hpp"
#include "firmware/interfaces/IEkf.hpp"

// #include "firmware/Params.hpp"
// #include "common/Common.hpp"
// #include "common/ClockFactory.hpp"
// #include "physics/Kinematics.hpp"       

constexpr float G_0 = 9.81f;      
constexpr float R_E = 6357000.0f;

namespace msr
{
namespace airlib
{

    class AirSimSimpleEkfModel
    {
    protected:
        // ---------------------------------------------------------------------
        // Mathematical functions
        // ---------------------------------------------------------------------

        void evaluateStateDot(float f_local[10], float x[17], float u[6])
        {
            // compute x_dot = f_local
            /*
            x[0] = x
            x[1] = y
            x[2] = z
            x[3] = u
            x[4] = v
            x[5] = w
            x[6] = q0
            x[7] = q1
            x[8] = q2
            x[9] = q3
            x[10] = bias_accel_x
            x[11] = bias_accel_y
            x[12] = bias_accel_z
            x[13] = bias_gyro_x
            x[14] = bias_gyro_x
            x[15] = bias_gyro_x
            x[16] = bias_baro

            u[0] = accel_x
            u[1] = accel_y
            u[2] = accel_z
            u[3] = gyro_x
            u[4] = gyro_y
            u[5] = gyro_z
            */     

            // f_pos
            f_local[0] = x[3];
            f_local[1] = x[4];
            f_local[2] = x[5];
            // f_vel
            f_local[3] =    (x[6]*x[6] + x[7]*x[7] - x[8]*x[8] - x[9]*x[9])*    (u[0] + x[10])
                            + 2.0f*(x[7]*x[8] - x[6]*x[9])*                        (u[1] + x[11])
                            + 2.0f*(x[6]*x[8] + x[7]*x[9])*                        (u[2] + x[12]);
            f_local[4] =    2.0f*(x[7]*x[8] + x[6]*x[9])*                          (u[0] + x[10])
                            + (x[6]*x[6] - x[7]*x[7] + x[8]*x[8] - x[9]*x[9])*  (u[1] + x[11])
                            + 2.0f*(x[8]*x[9] - x[6]*x[7])*                        (u[2] + x[12]);
            f_local[5] =    2.0f*(x[7]*x[9] - x[6]*x[8])*                          (u[0] + x[10])
                            + 2.0f*(x[8]*x[9] + x[6]*x[7])*                        (u[1] + x[11])
                            + (x[6]*x[6] - x[7]*x[7] - x[8]*x[8] + x[9]*x[9])*  (u[2] + x[12])
                            + G_0*(1 + 2.0f*x[2]/R_E);
            // f_ori
            f_local[6] = 0.5f * (-x[7]*(u[3] + x[13]) - x[8]*(u[4] + x[14]) - x[9]*(u[5] + x[15]));
            f_local[7] = 0.5f * ( x[6]*(u[3] + x[13]) - x[9]*(u[4] + x[14]) - x[8]*(u[5] + x[15]));
            f_local[8] = 0.5f * ( x[9]*(u[3] + x[13]) + x[6]*(u[4] + x[14]) - x[7]*(u[5] + x[15]));
            f_local[9] = 0.5f * (-x[8]*(u[3] + x[13]) + x[7]*(u[4] + x[14]) + x[6]*(u[5] + x[15]));

        }

        void h_mag()
        {
            // 
        }

        void h_baro()
        {
            // 
        }

        void h_GPS()
        {
            // 
        }

        // ---------------------------------------------------------------------
        // Mathematical jacobians
        // ---------------------------------------------------------------------

        void evaluateA(VectorMath::Matrix17x17f* A, float x[17], float u[6])
        {
            // compute jacobian wrt the states vector df_dx = A
            /*
            x[0] = x
            x[1] = y
            x[2] = z
            x[3] = u
            x[4] = v
            x[5] = w
            x[6] = q0
            x[7] = q1
            x[8] = q2
            x[9] = q3
            x[10] = bias_accel_x
            x[11] = bias_accel_y
            x[12] = bias_accel_z
            x[13] = bias_gyro_x
            x[14] = bias_gyro_x
            x[15] = bias_gyro_x
            x[16] = bias_baro

            u[0] = accel_x
            u[1] = accel_y
            u[2] = accel_z
            u[3] = gyro_x
            u[4] = gyro_y
            u[5] = gyro_z
            */  

            // // set all elements to zero
            // memset(&A[0][0], 0, sizeof(A)); 

            // // df_pos_dx [0 1 2][:]
            // A[0][3] = 1.0f;
            // A[1][4] = 1.0f;
            // A[2][5] = 1.0f;
            // // df_vel_dx [3 4 5][:]
            // A[5][2] = 2.0f*G_0/R_E;
            // // df_vel_q0 [3 4 5][6]
            // A[3][6] =  2.0f*x[6]*(u[0] + x[10]) - 2.0f*x[9]*(u[1] + x[11]) + 2.0f*x[8]*(u[2] + x[12]);
            // A[4][6] =  2.0f*x[9]*(u[0] + x[10]) + 2.0f*x[6]*(u[1] + x[11]) - 2.0f*x[7]*(u[2] + x[12]);
            // A[5][6] =  2.0f*x[8]*(u[0] + x[10]) - 2.0f*x[7]*(u[1] + x[11]) + 2.0f*x[6]*(u[2] + x[12]);
            // // df_vel_q1 [3 4 5][7]
            // A[3][7] =  2.0f*x[7]*(u[0] + x[10]) + 2.0f*x[8]*(u[1] + x[11]) + 2.0f*x[9]*(u[2] + x[12]);
            // A[4][7] =  2.0f*x[8]*(u[0] + x[10]) - 2.0f*x[7]*(u[1] + x[11]) - 2.0f*x[6]*(u[2] + x[12]);
            // A[5][7] =  2.0f*x[9]*(u[0] + x[10]) + 2.0f*x[6]*(u[1] + x[11]) - 2.0f*x[7]*(u[2] + x[12]);
            // // df_vel_q2 [3 4 5][8]
            // A[3][8] = -2.0f*x[8]*(u[0] + x[10]) + 2.0f*x[7]*(u[1] + x[11]) + 2.0f*x[6]*(u[2] + x[12]);
            // A[4][8] =  2.0f*x[7]*(u[0] + x[10]) + 2.0f*x[8]*(u[1] + x[11]) + 2.0f*x[9]*(u[2] + x[12]);
            // A[5][8] = -2.0f*x[6]*(u[0] + x[10]) + 2.0f*x[9]*(u[1] + x[11]) - 2.0f*x[8]*(u[2] + x[12]);
            // // df_vel_q3 [3 4 5][9]
            // A[3][9] = -2.0f*x[9]*(u[0] + x[10]) - 2.0f*x[6]*(u[1] + x[11]) + 2.0f*x[7]*(u[2] + x[12]);
            // A[4][9] =  2.0f*x[6]*(u[0] + x[10]) - 2.0f*x[9]*(u[1] + x[11]) + 2.0f*x[8]*(u[2] + x[12]);
            // A[5][9] =  2.0f*x[7]*(u[0] + x[10]) + 2.0f*x[8]*(u[1] + x[11]) + 2.0f*x[9]*(u[2] + x[12]);
            // // df_vel_xbias [3 4 5][10 11 12 ...]
            // A[3][10] =    x[6]*x[6] + x[7]*x[7] - x[8]*x[8] - x[9]*x[9];
            // A[3][11] = 2.0f*(x[7]*x[8] - x[6]*x[9]);
            // A[3][12] = 2.0f*(x[6]*x[8] + x[7]*x[9]);
            // A[4][10] = 2.0f*(x[7]*x[8] + x[6]*x[9]);
            // A[4][11] =    x[6]*x[6] - x[7]*x[7] + x[8]*x[8] - x[9]*x[9];
            // A[4][12] = 2.0f*(x[8]*x[9] - x[6]*x[7]);
            // A[5][10] = 2.0f*(x[7]*x[9] - x[6]*x[8]);
            // A[5][11] = 2.0f*(x[8]*x[9] + x[6]*x[7]);
            // A[5][12] =    x[6]*x[6] - x[7]*x[7] - x[8]*x[8] + x[9]*x[9];
            // // df_ori_[q0 q1 q2 q3] [6 7 8 9][6 7 8 9]
            // A[6][7] = -0.5f*(u[3] + x[13]);
            // A[6][8] = -0.5f*(u[4] + x[14]);
            // A[6][9] = -0.5f*(u[5] + x[15]);
            // A[7][6] =  0.5f*(u[3] + x[13]);
            // A[7][8] = -0.5f*(u[5] + x[15]);
            // A[7][9] = -0.5f*(u[4] + x[14]);
            // A[8][6] =  0.5f*(u[4] + x[14]);
            // A[8][7] = -0.5f*(u[5] + x[15]);
            // A[8][9] =  0.5f*(u[3] + x[13]);
            // A[9][6] =  0.5f*(u[5] + x[15]);
            // A[9][7] =  0.5f*(u[4] + x[14]);
            // A[9][8] = -0.5f*(u[3] + x[13]);
            // // df_ori_x_bias [6 7 8 9][10 11 12 13 14 15 16 17]
            // A[6][13] = -0.5f*x[7];
            // A[6][14] = -0.5f*x[8];
            // A[6][15] = -0.5f*x[9];
            // A[7][13] =  0.5f*x[6];
            // A[7][14] = -0.5f*x[9];
            // A[7][15] = -0.5f*x[8];
            // A[8][13] =  0.5f*x[9];
            // A[8][14] =  0.5f*x[6];
            // A[8][15] = -0.5f*x[7];
            // A[9][13] = -0.5f*x[8];
            // A[9][14] =  0.5f*x[7];
            // A[9][15] =  0.5f*x[6];

            *A = VectorMath::Matrix17x17f::Zero(); 

            // df_pos_dx [0 1 2][:]
            (*A)(0, 3) = 1.0f;
            (*A)(1, 4) = 1.0f;
            (*A)(2, 5) = 1.0f;
            // df_vel_dx [3 4 5][:]
            (*A)(5, 2) = 2.0f*G_0/R_E;
            // df_vel_q0 [3 4 5][6]
            (*A)(3, 6) =  2.0f*x[6]*(u[0] + x[10]) - 2.0f*x[9]*(u[1] + x[11]) + 2.0f*x[8]*(u[2] + x[12]);
            (*A)(4, 6) =  2.0f*x[9]*(u[0] + x[10]) + 2.0f*x[6]*(u[1] + x[11]) - 2.0f*x[7]*(u[2] + x[12]);
            (*A)(5, 6) =  2.0f*x[8]*(u[0] + x[10]) - 2.0f*x[7]*(u[1] + x[11]) + 2.0f*x[6]*(u[2] + x[12]);
            // df_vel_q1 [3 4 5][7]
            (*A)(3, 7) =  2.0f*x[7]*(u[0] + x[10]) + 2.0f*x[8]*(u[1] + x[11]) + 2.0f*x[9]*(u[2] + x[12]);
            (*A)(4, 7) =  2.0f*x[8]*(u[0] + x[10]) - 2.0f*x[7]*(u[1] + x[11]) - 2.0f*x[6]*(u[2] + x[12]);
            (*A)(5, 7) =  2.0f*x[9]*(u[0] + x[10]) + 2.0f*x[6]*(u[1] + x[11]) - 2.0f*x[7]*(u[2] + x[12]);
            // df_vel_q2 [3 4 5][8]
            (*A)(3, 8) = -2.0f*x[8]*(u[0] + x[10]) + 2.0f*x[7]*(u[1] + x[11]) + 2.0f*x[6]*(u[2] + x[12]);
            (*A)(4, 8) =  2.0f*x[7]*(u[0] + x[10]) + 2.0f*x[8]*(u[1] + x[11]) + 2.0f*x[9]*(u[2] + x[12]);
            (*A)(5, 8) = -2.0f*x[6]*(u[0] + x[10]) + 2.0f*x[9]*(u[1] + x[11]) - 2.0f*x[8]*(u[2] + x[12]);
            // df_vel_q3 [3 4 5][9]
            (*A)(3, 9) = -2.0f*x[9]*(u[0] + x[10]) - 2.0f*x[6]*(u[1] + x[11]) + 2.0f*x[7]*(u[2] + x[12]);
            (*A)(4, 9) =  2.0f*x[6]*(u[0] + x[10]) - 2.0f*x[9]*(u[1] + x[11]) + 2.0f*x[8]*(u[2] + x[12]);
            (*A)(5, 9) =  2.0f*x[7]*(u[0] + x[10]) + 2.0f*x[8]*(u[1] + x[11]) + 2.0f*x[9]*(u[2] + x[12]);
            // df_vel_xbias [3 4 5][10 11 12 ...]
            (*A)(3, 10) =    x[6]*x[6] + x[7]*x[7] - x[8]*x[8] - x[9]*x[9];
            (*A)(3, 11) = 2.0f*(x[7]*x[8] - x[6]*x[9]);
            (*A)(3, 12) = 2.0f*(x[6]*x[8] + x[7]*x[9]);
            (*A)(4, 10) = 2.0f*(x[7]*x[8] + x[6]*x[9]);
            (*A)(4, 11) =    x[6]*x[6] - x[7]*x[7] + x[8]*x[8] - x[9]*x[9];
            (*A)(4, 12) = 2.0f*(x[8]*x[9] - x[6]*x[7]);
            (*A)(5, 10) = 2.0f*(x[7]*x[9] - x[6]*x[8]);
            (*A)(5, 11) = 2.0f*(x[8]*x[9] + x[6]*x[7]);
            (*A)(5, 12) =    x[6]*x[6] - x[7]*x[7] - x[8]*x[8] + x[9]*x[9];
            // df_ori_[q0 q1 q2 q3] [6 7 8 9][6 7 8 9]
            (*A)(6, 7)= -0.5f*(u[3] + x[13]);
            (*A)(6, 8)= -0.5f*(u[4] + x[14]);
            (*A)(6, 9)= -0.5f*(u[5] + x[15]);
            (*A)(7, 6)=  0.5f*(u[3] + x[13]);
            (*A)(7, 8)= -0.5f*(u[5] + x[15]);
            (*A)(7, 9)= -0.5f*(u[4] + x[14]);
            (*A)(8, 6)=  0.5f*(u[4] + x[14]);
            (*A)(8, 7)= -0.5f*(u[5] + x[15]);
            (*A)(8, 9)=  0.5f*(u[3] + x[13]);
            (*A)(9, 6)=  0.5f*(u[5] + x[15]);
            (*A)(9, 7)=  0.5f*(u[4] + x[14]);
            (*A)(9, 8)= -0.5f*(u[3] + x[13]);
            // df_ori_x_bias [6 7 8 9][10 11 12 13 14 15 16 17]
            (*A)(6, 13) = -0.5f*x[7];
            (*A)(6, 14) = -0.5f*x[8];
            (*A)(6, 15) = -0.5f*x[9];
            (*A)(7, 13) =  0.5f*x[6];
            (*A)(7, 14) = -0.5f*x[9];
            (*A)(7, 15) = -0.5f*x[8];
            (*A)(8, 13) =  0.5f*x[9];
            (*A)(8, 14) =  0.5f*x[6];
            (*A)(8, 15) = -0.5f*x[7];
            (*A)(9, 13) = -0.5f*x[8];
            (*A)(9, 14) =  0.5f*x[7];
            (*A)(9, 15) =  0.5f*x[6];
        }

        void evaluateB_w(VectorMath::Matrix17x13f* B_w, float x[17], float u[6])
        {
            // compute jacobian wrt the process noise vector df_dw
            /*
            x[0] = x
            x[1] = y
            x[2] = z
            x[3] = u
            x[4] = v
            x[5] = w
            x[6] = q0
            x[7] = q1
            x[8] = q2
            x[9] = q3
            x[10] = bias_accel_x
            x[11] = bias_accel_y
            x[12] = bias_accel_z
            x[13] = bias_gyro_x
            x[14] = bias_gyro_x
            x[15] = bias_gyro_x
            x[16] = bias_baro

            u[0] = accel_x
            u[1] = accel_y
            u[2] = accel_z
            u[3] = gyro_x
            u[4] = gyro_y
            u[5] = gyro_z
            */  

            // // set all elements to zero
            // memset(&B_w[0][0], 0, sizeof(B_w)); 

            // // df_vel_w [3 4 5][0 1 2 ...]
            // B_w[3][0] =    x[6]*x[6] + x[7]*x[7] - x[8]*x[8] - x[9]*x[9];
            // B_w[3][1] = 2.0f*(x[7]*x[8] - x[6]*x[9]);
            // B_w[3][2] = 2.0f*(x[6]*x[8] + x[7]*x[9]);
            // B_w[4][0] = 2.0f*(x[7]*x[8] + x[6]*x[9]);
            // B_w[4][1] =    x[6]*x[6] - x[7]*x[7] + x[8]*x[8] - x[9]*x[9];
            // B_w[4][2] = 2.0f*(x[8]*x[9] - x[6]*x[7]);
            // B_w[5][0] = 2.0f*(x[7]*x[9] - x[6]*x[8]);
            // B_w[5][1] = 2.0f*(x[8]*x[9] + x[6]*x[7]);
            // B_w[5][2] =    x[6]*x[6] - x[7]*x[7] - x[8]*x[8] + x[9]*x[9];
            // // df_ori_x_bias [6 7 8 9][10 11 12 13 14 15 16 17]
            // B_w[6][3] = -0.5f*x[7];
            // B_w[6][4] = -0.5f*x[8];
            // B_w[6][5] = -0.5f*x[9];
            // B_w[7][3] =  0.5f*x[6];
            // B_w[7][4] = -0.5f*x[9];
            // B_w[7][5] = -0.5f*x[8];
            // B_w[8][3] =  0.5f*x[9];
            // B_w[8][4] =  0.5f*x[6];
            // B_w[8][5] = -0.5f*x[7];
            // B_w[9][3] = -0.5f*x[8];
            // B_w[9][4] =  0.5f*x[7];
            // B_w[9][5] =  0.5f*x[6];
            // // df_bias_w
            // B_w[10][6] =  1.0f;
            // B_w[11][7] =  1.0f;
            // B_w[12][8] =  1.0f;
            // B_w[13][9] =  1.0f;
            // B_w[14][10] =  1.0f;
            // B_w[15][11] =  1.0f;
            // B_w[16][12] =  1.0f;

            // set all elements to zero
            *B_w = VectorMath::Matrix17x13f::Zero(); 

            // df_vel_w [3 4 5][0 1 2 ...]
            (*B_w)(3, 0) =    x[6]*x[6] + x[7]*x[7] - x[8]*x[8] - x[9]*x[9];
            (*B_w)(3, 1) = 2.0f*(x[7]*x[8] - x[6]*x[9]);
            (*B_w)(3, 2) = 2.0f*(x[6]*x[8] + x[7]*x[9]);
            (*B_w)(4, 0) = 2.0f*(x[7]*x[8] + x[6]*x[9]);
            (*B_w)(4, 1) =    x[6]*x[6] - x[7]*x[7] + x[8]*x[8] - x[9]*x[9];
            (*B_w)(4, 2) = 2.0f*(x[8]*x[9] - x[6]*x[7]);
            (*B_w)(5, 0) = 2.0f*(x[7]*x[9] - x[6]*x[8]);
            (*B_w)(5, 1) = 2.0f*(x[8]*x[9] + x[6]*x[7]);
            (*B_w)(5, 2) =    x[6]*x[6] - x[7]*x[7] - x[8]*x[8] + x[9]*x[9];
            // df_ori_x_bias [6 7 8 9][10 11 12 13 14 15 16 17]
            (*B_w)(6, 3) = -0.5f*x[7];
            (*B_w)(6, 4) = -0.5f*x[8];
            (*B_w)(6, 5) = -0.5f*x[9];
            (*B_w)(7, 3) =  0.5f*x[6];
            (*B_w)(7, 4) = -0.5f*x[9];
            (*B_w)(7, 5) = -0.5f*x[8];
            (*B_w)(8, 3) =  0.5f*x[9];
            (*B_w)(8, 4) =  0.5f*x[6];
            (*B_w)(8, 5) = -0.5f*x[7];
            (*B_w)(9, 3) = -0.5f*x[8];
            (*B_w)(9, 4) =  0.5f*x[7];
            (*B_w)(9, 5) =  0.5f*x[6];
            // df_bias_w
            (*B_w)(10, 6) =  1.0f;
            (*B_w)(11, 7) =  1.0f;
            (*B_w)(12, 8) =  1.0f;
            (*B_w)(13, 9) =  1.0f;
            (*B_w)(14, 10) =  1.0f;
            (*B_w)(15, 11) =  1.0f;
            (*B_w)(16, 12) =  1.0f;
        }

        void dh_mag_dx()
        {
            // jacobian wrt the states vector
        }

        void dh_baro_dx()
        {
            // jacobian wrt the states vector
        }

        void dh_GPS_dx()
        {
            // jacobian wrt the states vector
        }

    };

}
} //namespace
#endif